### 01 Java 运行时数据区（内存区域）
按照线程使用情况分为 **线程独享** 和 **线程共享**    
线程使用情况 | 举例
------------------- | ------------------
 线程共享（数据存储区域）| • 堆和方法区 <br> • 存储类的静态数据和对象数据 <br> • 需要垃圾回收
 线程独享（程序执行区域）| • 虚拟机栈、本地方法栈、程序计数器 <br> • 不需要垃圾回收

##### 堆
在 Java 虚拟机启动时创建内存区域去实现所有类实例、数组与运行时常量的内存均从此处分配，是垃圾回收的主要内存区域。

##### 虚拟机栈
每个线程创建时都会创建一个虚拟机栈，每个 Java 方法在执行的时候都会创建一个栈帧（Stack Frame），虚拟机栈用于保存这些方法的栈帧。

##### 本地方法栈
与虚拟机栈相似，其区别是本地方法栈为虚拟机使用到的 Native 方法服务。

##### 方法区（永久代、元空间）
虚拟机规范中定义的用于存储类型信息、常量池、字段信息、方法信息、类变量、指向类加载器的引用、指向 Class 实例的引用、方法表的一个概念。

##### 运行时常量池（字符串常量池）
- **运行时常量池**：存储编译后的类信息，一个 class 对象有一个运行时常量池。  
- **字符串常量池**：虚拟机维护的一个字符串实例的引用表（类似于哈希表），全局只有一个。

##### 直接内存
直接内存就是把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），也就是说不是虚拟机运行时数据区的一部分。

#### 为什么堆内存要分年轻代和老年代？
一句话就是为了**提高效率**。  
根据程序的对象数据使用经验，当前的虚拟机垃圾收集器设计都遵循了该经验建立的分代收集理论：
- **弱分代假说**： 绝大多数对象就是朝生夕灭。
- **强分代假说**： 越是熬过多次垃圾回收的对象越是难以回收消亡。

这样，为了减少垃圾回收时遍历的对象数，提高回收效率，给堆内存分代为年轻代和老年代。

### 02 描述一个 Java 对象的声明周期
#### • 解释一个对象的创建过程
![](attachments/Pasted%20image%2020220905002542.png)

#### • 解释一个对象的内存分配
首先从本地线程缓存进行预分配，如果分配不到，再通过下面两种内存分配方式把一块确定大小的内存从堆中划分出来。
- 指针碰撞： GC 不带压缩功能，Serial 和 ParNew
- 空闲列表：GC 带压缩功能，CMS

#### • 解释一个对象的销毁过程
没有被引用的对象将由垃圾回收器收集然后释放。

#### • 对象的 2 种访问方式是什么？
- **通过句柄访问**：稳定，对象被移动只需要修改句柄中的地址。
- **通过直接指针访问**：访问速度快，节省了一次指针定位的开销。

#### • 为什么需要内存担保？
如果大量对象在 Minor GC 后仍然存活（最极端情况为内存回收后新生代中所有对象均存活），而 Survivor 空间是比较小的，这时就需要老年代进行分配担保，把 Survivor 无法容纳的对象放到老年代。例如：大对象直接进入老年代就是内存（通过\[-XX:PretenureSizeThreshold\]设置）担保机制的一种体现。

### 03 垃圾收集算法有哪些？垃圾收集器有哪些？他们特点是什么？
#### 垃圾收集算法
垃圾收集算法主要有**引用计数法**和**根可达算法**。

#### 垃圾收集器及对应的特点
收集器 | 特点
----- | ----
Serial/Serial Old | • 单线程<br> • 独占式<br> • 成熟<br> • 适合单 CPU 环境
ParNew | • Serial 多线程版本<br> • 新生代并行（ParNew），老年代串行
Parallel Scavenge | • 吞吐量优先<br> • 新生代使用并行回收收集器，采用复制算法<br> • 老年代使用串行收集器
Parallel Old | • Parallel Scavenge 的老年代版本<br> • 多线程<br> • 采用“标记-整理”算法
CMS | • 低延迟<br> • 并发收集<br> • 堆内存使用率达到某一阈值便开始回收<br> • 采用“标记-清楚”算法<br> • 会产生内存碎片，导致并发清除后，用户线程可用的空间不足<br> • 对 CPU 资源非常敏感
G1 | • 并行与并发收集<br> • 多代收集<br> • 空间整合<br> • 停顿可控





