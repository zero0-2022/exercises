### 01 Java 运行时数据区（内存区域）
按照线程使用情况分为 **线程独享** 和 **线程共享**    
线程使用情况 | 举例
------------------- | ------------------
 线程共享（数据存储区域）| • 堆和方法区 <br> • 存储类的静态数据和对象数据 <br> • 需要垃圾回收
 线程独享（程序执行区域）| • 虚拟机栈、本地方法栈、程序计数器 <br> • 不需要垃圾回收
 

##### 堆
在 Java 虚拟机启动时创建内存区域去实现所有类实例、数组与运行时常量的内存均从此处分配，是垃圾回收的主要内存区域。

##### 虚拟机栈
每个线程创建时都会创建一个虚拟机栈，每个 Java 方法在执行的时候都会创建一个栈帧（Stack Frame），虚拟机栈用于保存这些方法的栈帧。

##### 本地方法栈
与虚拟机栈相似，其区别是本地方法栈为虚拟机使用到的 Native 方法服务。

##### 方法区（永久代、元空间）
虚拟机规范中定义的用于存储类型信息、常量池、字段信息、方法信息、类变量、指向类加载器的引用、指向 Class 实例的引用、方法表的一个概念。

##### 运行时常量池（字符串常量池）
- **运行时常量池**：存储编译后的类信息，一个 class 对象有一个运行时常量池。  
- **字符串常量池**：虚拟机维护的一个字符串实例的引用表（类似于哈希表），全局只有一个。

##### 直接内存
直接内存就是把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），也就是说不是虚拟机运行时数据区的一部分。

#### 为什么堆内存要分年轻代和老年代？
一句话就是为了**提高效率**。  
根据程序的对象数据使用经验，当前的虚拟机垃圾收集器设计都遵循了该经验建立的分代收集理论：
- **弱分代假说**： 绝大多数对象就是朝生夕灭。
- **强分代假说**： 越是熬过多次垃圾回收的对象越是难以回收消亡。

这样，为了减少垃圾回收时遍历的对象数，提高回收效率，给堆内存分代为年轻代和老年代。




### 02 描述一个 Java 对象的声明周期
#### • 解释一个对象的创建过程
```flow
st=>start: 开始
```

#### • 解释一个对象的内存分配
- 指针碰撞： GC 不带压缩功能，Serial 和 ParNew
- 空闲列表：GC 带压缩功能，CMS

#### • 解释一个对象的销毁过程
#### • 对象的 2 种访问方式是什么？
#### • 为什么需要内存担保？

### 03 垃圾收集算法有哪些？垃圾收集器有哪些？他们特点是什么？


